name: BDV Cron (scan + monitor)

on:
  schedule:
    # Ventana amplia UTC para cubrir 9:30â€“16:00 ET incluso con DST.
    # El backend decide si in_rth=true/false.
    - cron: "*/5 13-21 * * 1-5"
  workflow_dispatch:

jobs:
  bdv:
    runs-on: ubuntu-latest
    timeout-minutes: 5

    steps:
      - name: Ensure AUTO + scan + tick (safe outside RTH)
        shell: bash
        run: |
          set -euo pipefail

          BASE="${{ secrets.BDV_BASE_URL }}"
          SECRET="${{ secrets.BDV_AGENT_SECRET }}"

          call() {
            local method="$1"
            local url="$2"
            local out="$3"
            local hdr="$4"

            echo "==> $method $url" >&2

            local http_code
            http_code=$(curl -sS --retry 5 --retry-delay 2 --retry-all-errors --max-time 20 \
              -X "$method" \
              -D "$hdr" \
              -o "$out" \
              -H "accept: application/json" \
              -H "x-bdv-secret: $SECRET" \
              -w "%{http_code}" \
              "$url" || true)

            echo "HTTP $http_code" >&2
            echo "-- headers (first 60 lines) --" >&2
            sed -n '1,60p' "$hdr" >&2 || true
            echo "-- body (first 2000 chars) --" >&2
            head -c 2000 "$out" >&2 || true
            echo >&2

            # SOLO el code por STDOUT (para command substitution)
            echo "$http_code"
          }

          # 1) Status
          code="$(call GET "$BASE/config/status" /tmp/status.json /tmp/status.hdr)"
          [[ "$code" == "200" ]] || { echo "FAIL: /config/status HTTP $code" >&2; exit 1; }

          # 2) Set AUTO (querystring definitivo)
          code="$(call POST "$BASE/config/execution-mode?mode=auto" /tmp/set_auto.json /tmp/set_auto.hdr)"
          [[ "$code" == "200" ]] || { echo "FAIL: /config/execution-mode HTTP $code" >&2; exit 1; }

          # 3) Scan
          code="$(call GET "$BASE/agent/scan?force_analysis=0" /tmp/scan.json /tmp/scan.hdr)"
          [[ "$code" == "200" ]] || { echo "FAIL: /agent/scan HTTP $code" >&2; exit 1; }

          # Decidir si corre tick (sin fallar fuera de RTH)
          RUN_TICK="$(python3 - <<'PY'
          import json
          data=json.load(open("/tmp/scan.json","r",encoding="utf-8"))
          in_rth=bool(data.get("in_rth", False))
          status=str(data.get("status","")).lower()
          reason=data.get("reason")
          print(f"in_rth={in_rth} status={status} reason={reason}", flush=True)
          # tick SOLO si estamos en RTH y operable
          operable = in_rth and status in ("ok","green")
          print("1" if operable else "0")
          PY
          | tail -n 1)"

          if [[ "$RUN_TICK" != "1" ]]; then
            echo "Not operable now (outside RTH or non-green) -> exit 0 (no failure)." >&2
            exit 0
          fi

          # 4) Tick
          code="$(call GET "$BASE/monitor/tick" /tmp/tick.json /tmp/tick.hdr)"
          [[ "$code" == "200" ]] || { echo "FAIL: /monitor/tick HTTP $code" >&2; exit 1; }

          echo "Done." >&2
