name: BDV Cron (scan + monitor)

on:
  schedule:
    # Ventana amplia en UTC para cubrir 9-4 ET aprox (y DST). El backend decide in_rth.
    - cron: "*/5 13-21 * * 1-5"
  workflow_dispatch:

jobs:
  bdv:
    runs-on: ubuntu-latest
    timeout-minutes: 5

    steps:
      - name: Ensure AUTO execution mode + run scan/monitor (safe outside RTH)
        shell: bash
        run: |
          set -euo pipefail

          BASE="${{ secrets.BDV_BASE_URL }}"
          SECRET="${{ secrets.BDV_AGENT_SECRET }}"

          call() {
            local method="$1"
            local url="$2"
            local out="$3"
            local headers="$4"

            echo "==> $method $url"
            # Guardamos body y headers SIEMPRE (evita curl 23 y te deja logs)
            http_code=$(curl -sS --retry 5 --retry-delay 2 --retry-all-errors --max-time 20 \
              -X "$method" \
              -D "$headers" \
              -o "$out" \
              -H "accept: application/json" \
              -H "x-bdv-secret: $SECRET" \
              -w "%{http_code}" \
              "$url" || true)

            echo "HTTP $http_code"
            echo "-- headers (first 80 lines) --"
            sed -n '1,80p' "$headers" || true
            echo "-- body (first 2000 chars) --"
            head -c 2000 "$out" || true
            echo
            echo "$http_code"
          }

          # 1) Status (si falla aquí, sí queremos enterarnos)
          code=$(call GET "$BASE/config/status" /tmp/status.json /tmp/status.hdr)
          if [[ "$code" != "200" ]]; then
            echo "ERROR: /config/status returned HTTP $code"
            exit 1
          fi

          # 2) Set AUTO via querystring (definitivo)
          code=$(call POST "$BASE/config/execution-mode?mode=auto" /tmp/set_auto.json /tmp/set_auto.hdr)
          if [[ "$code" != "200" ]]; then
            echo "ERROR: /config/execution-mode returned HTTP $code"
            exit 1
          fi

          # 3) Scan (NO fallar fuera de RTH)
          code=$(call GET "$BASE/agent/scan?force_analysis=0" /tmp/scan.json /tmp/scan.hdr)
          if [[ "$code" != "200" ]]; then
            echo "ERROR: /agent/scan returned HTTP $code"
            exit 1
          fi

          # Si in_rth=false => salimos OK (no marcar failure)
          python3 - <<'PY'
          import json, sys
          p = "/tmp/scan.json"
          with open(p, "r", encoding="utf-8") as f:
            data = json.load(f)

          in_rth = bool(data.get("in_rth", False))
          status = str(data.get("status", "")).lower()
          reason = data.get("reason")

          print(f"[scan] in_rth={in_rth} status={status} reason={reason}")

          # Fuera de RTH: éxito silencioso
          if not in_rth:
            sys.exit(0)

          # Dentro de RTH pero semáforo no está ok/green: no reventar el workflow (solo no operar)
          # Ajusta si quieres que 'yellow' dentro de RTH sea failure.
          if status not in ("ok", "green"):
            sys.exit(0)

          sys.exit(1)  # señal para continuar al tick usando bash
          PY

          pycode=$?
          if [[ "$pycode" == "0" ]]; then
            echo "Outside RTH OR not operable now -> exit 0 (no failure)."
            exit 0
          fi

          echo "In RTH and operable -> running /monitor/tick..."

          # 4) Tick (aquí sí: si falla, queremos verlo)
          code=$(call GET "$BASE/monitor/tick" /tmp/tick.json /tmp/tick.hdr)
          if [[ "$code" != "200" ]]; then
            echo "ERROR: /monitor/tick returned HTTP $code"
            exit 1
          fi

          echo "Done."
