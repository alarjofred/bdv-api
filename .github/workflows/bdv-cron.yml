name: BDV Cron (scan + monitor)

on:
  schedule:
    # Corre L-V cada 5 min. El "gate" real lo hace in_rth (evita DST/UTC headaches)
    - cron: "*/5 * * * 1-5"
  workflow_dispatch: {}

jobs:
  bdv:
    runs-on: ubuntu-latest
    timeout-minutes: 5

    steps:
      - name: Ensure AUTO execution mode (querystring) + log config (robust)
        shell: bash
        run: |
          set -euo pipefail

          hit () {
            local label="$1"
            local method="$2"
            local url="$3"
            local out_headers="$4"
            local out_body="$5"
            local out_code="$6"

            echo "===== ${label} ====="
            echo "${method} ${url}"

            curl -sS --fail-with-body \
              --retry 5 --retry-delay 2 --retry-all-errors \
              --connect-timeout 5 --max-time 25 \
              -X "${method}" \
              -D "${out_headers}" \
              -o "${out_body}" \
              -H "accept: application/json" \
              -H "x-bdv-secret: ${{ secrets.BDV_AGENT_SECRET }}" \
              -w "%{http_code}" \
              "${url}" > "${out_code}"

            local code
            code="$(cat "${out_code}" || true)"
            echo "HTTP ${code}"

            echo "---- headers (${label}) ----"
            head -c 2000 "${out_headers}" || true
            echo
            echo "---- body (${label}) ----"
            head -c 2000 "${out_body}" || true
            echo

            if [[ "${code}" != "200" ]]; then
              echo "ERROR: ${label} returned HTTP ${code}"
              exit 1
            fi
          }

          BASE="${{ secrets.BDV_BASE_URL }}"

          hit "config status (before)" "GET"  "${BASE}/config/status" \
            "/tmp/headers_status.txt" "/tmp/body_status.txt" "/tmp/code_status.txt"

          hit "set exec_mode=auto (querystring)" "POST" "${BASE}/config/execution-mode?mode=auto" \
            "/tmp/headers_set.txt" "/tmp/body_set.txt" "/tmp/code_set.txt"

          hit "config status (after)" "GET" "${BASE}/config/status" \
            "/tmp/headers_status2.txt" "/tmp/body_status2.txt" "/tmp/code_status2.txt"

      - name: Call /agent/scan (gatekeeper: decide if in RTH)
        id: scan
        shell: bash
        run: |
          set -euo pipefail
          BASE="${{ secrets.BDV_BASE_URL }}"

          curl -sS --fail-with-body \
            --retry 5 --retry-delay 2 --retry-all-errors \
            --connect-timeout 5 --max-time 25 \
            -D /tmp/headers_scan.txt \
            -o /tmp/body_scan.txt \
            "${BASE}/agent/scan?force_analysis=0" \
            -H "accept: application/json" \
            -H "x-bdv-secret: ${{ secrets.BDV_AGENT_SECRET }}" \
            -w "%{http_code}" > /tmp/code_scan.txt

          code="$(cat /tmp/code_scan.txt || true)"
          echo "HTTP ${code}"
          echo "---- headers (scan) ----"
          head -c 2000 /tmp/headers_scan.txt || true
          echo
          echo "---- body (scan) ----"
          head -c 2000 /tmp/body_scan.txt || true
          echo

          if [[ "${code}" != "200" ]]; then
            echo "ERROR: /agent/scan returned HTTP ${code}"
            exit 1
          fi

          # Parse JSON safely with python (no depende de jq)
          python - <<'PY'
          import json, sys
          p = "/tmp/body_scan.txt"
          try:
            data = json.load(open(p, "r", encoding="utf-8"))
          except Exception as e:
            print(f"FAILED parsing scan JSON: {e}")
            sys.exit(1)

          in_rth = bool(data.get("in_rth", False))
          status = str(data.get("status", "")).lower()
          reason = str(data.get("reason", ""))

          # Export outputs for next steps
          with open(sys.argv[1], "a", encoding="utf-8") as f:
            f.write(f"in_rth={'true' if in_rth else 'false'}\n")
            f.write(f"scan_status={status}\n")

          print("Parsed:")
          print("  in_rth:", in_rth)
          print("  status:", status)
          print("  reason:", reason)
          PY "$GITHUB_OUTPUT"

          # Si NO estÃ¡ en RTH -> termina OK (sin fallar)
          if [[ "${{ steps.scan.outputs.in_rth }}" != "true" ]]; then
            echo "Outside RTH (in_rth=false). Exiting SUCCESS (no monitor/tick)."
            exit 0
          fi

      - name: Call /monitor/tick (ONLY if in RTH)
        if: steps.scan.outputs.in_rth == 'true'
        shell: bash
        run: |
          set -euo pipefail
          BASE="${{ secrets.BDV_BASE_URL }}"

          curl -sS --fail-with-body \
            --retry 5 --retry-delay 2 --retry-all-errors \
            --connect-timeout 5 --max-time 25 \
            -D /tmp/headers_tick.txt \
            -o /tmp/body_tick.txt \
            "${BASE}/monitor/tick" \
            -H "accept: application/json" \
            -H "x-bdv-secret: ${{ secrets.BDV_AGENT_SECRET }}" \
            -w "%{http_code}" > /tmp/code_tick.txt

          echo "HTTP $(cat /tmp/code_tick.txt || true)"
          echo "---- headers (tick) ----"
          head -c 2000 /tmp/headers_tick.txt || true
          echo
          echo "---- body (tick) ----"
          head -c 2000 /tmp/body_tick.txt || true
          echo

          if [[ "$(cat /tmp/code_tick.txt || true)" != "200" ]]; then
            echo "ERROR: /monitor/tick returned non-200"
            exit 1
          fi
