name: BDV Cron

on:
  schedule:
    - cron: "*/5 * * * 1-5" # cada 5 min (UTC). Guard decide por NY time.
  workflow_dispatch:

jobs:
  bdv:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - name: BDV guard + calls
        env:
          BASE_URL: ${{ secrets.BDV_BASE_URL }}
          BDV_AGENT_SECRET: ${{ secrets.BDV_AGENT_SECRET }}
       run: |
  set -euo pipefail

  sudo apt-get update -y
  sudo apt-get install -y jq

  if [ -z "${BASE_URL:-}" ]; then
    echo "FAIL: BASE_URL is EMPTY"
    exit 1
  fi

  if [ -z "${BDV_AGENT_SECRET:-}" ]; then
    echo "FAIL: BDV_AGENT_SECRET is EMPTY"
    exit 1
  fi

  # Normaliza BASE_URL (sin slash final)
  BASE_URL="${BASE_URL%/}"

  echo "BASE_URL_HOST=$(echo "$BASE_URL" | sed -E 's#https?://##' | cut -d/ -f1)"
  echo "BDV_AGENT_SECRET_LEN=${#BDV_AGENT_SECRET}"

  TZ="America/New_York"
  dow=$(TZ=$TZ date +%u)         # 1..7
  hhmm=$(TZ=$TZ date +%H%M)      # 0000..2359
  now_iso=$(TZ=$TZ date +"%Y-%m-%d %H:%M:%S %Z")
  echo "NY_TIME=$now_iso (dow=$dow hhmm=$hhmm)"

  if [ "$dow" -ge 6 ]; then
    echo "Outside RTH (weekend) -> exit OK"
    exit 0
  fi

  RTH_START=0930
  RTH_END=1600
  if [ "$hhmm" -lt "$RTH_START" ] || [ "$hhmm" -ge "$RTH_END" ]; then
    echo "Outside RTH: now=$hhmm NY -> exit OK"
    exit 0
  fi

  echo "Inside RTH: now=$hhmm NY -> running endpoints"

  curl_json() {
    local method="$1"
    local path="$2"
    local url="${BASE_URL}${path}"
    local tmp_body
    tmp_body="$(mktemp)"

    local http_code
    http_code=$(
      curl -sS -o "$tmp_body" -w "%{http_code}" \
        -X "$method" \
        -H "X-BDV-SECRET: ${BDV_AGENT_SECRET}" \
        -H "accept: application/json" \
        --retry 2 --retry-delay 1 --retry-connrefused \
        --connect-timeout 10 --max-time 30 \
        "$url" || echo "000"
    )

    local snippet
    snippet=$(head -c 300 "$tmp_body" | tr '\n' ' ' | sed 's/  */ /g')
    echo "ENDPOINT ${method} ${path} -> http_code=${http_code} | body_snippet=${snippet}"

    if [ "$http_code" != "200" ]; then
      echo "FAIL: ${method} ${path} returned ${http_code}"
      echo "BODY_START"
      cat "$tmp_body"
      echo "BODY_END"
      rm -f "$tmp_body"
      exit 1
    fi

    cat "$tmp_body"
    rm -f "$tmp_body"
  }

  # 1) Set AUTO
  curl_json "POST" "/config/execution-mode?mode=auto" >/dev/null

  # 2) Set MEDIUM
  curl_json "POST" "/config/risk-mode?mode=medium" >/dev/null

  # 3) Verify status (y si no es JSON, fallará antes por http_code != 200)
  cfg="$(curl_json "GET" "/config/status")"
  mode="$(echo "$cfg" | jq -r '.execution_mode // empty')"
  risk="$(echo "$cfg" | jq -r '.risk_mode // empty')"
  echo "CHECK config/status -> execution_mode=${mode} risk_mode=${risk}"

  if [ "$mode" != "auto" ]; then
    echo "FAIL: execution_mode is not auto"
    exit 1
  fi

  if [ "$risk" != "medium" ]; then
    echo "FAIL: risk_mode is not medium"
    exit 1
  fi

  # 4) Scan
  curl_json "GET" "/agent/scan" >/dev/null

  # 5) Tick (aquí es donde tú estabas viendo 401)
  tick="$(curl_json "GET" "/monitor/tick")"
  tstatus="$(echo "$tick" | jq -r '.status // empty')"
  treason="$(echo "$tick" | jq -r '.reason // empty')"
  echo "CHECK monitor/tick -> status=${tstatus} reason=${treason}"

  if [ "$tstatus" = "skipped" ]; then
    echo "FAIL: monitor/tick skipped inside RTH -> ${treason}"
    exit 1
  fi

  echo "All checks OK inside RTH."
