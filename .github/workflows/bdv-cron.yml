name: BDV Cron

on:
  schedule:
    - cron: "*/5 * * * 1-5"   # cada 5 min, lun-vie (UTC). El guard decide por ET.
  workflow_dispatch:

jobs:
  bdv:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - name: BDV guard + calls
        env:
          BASE_URL: ${{ secrets.BDV_BASE_URL }}
          API_KEY: ${{ secrets.BDV_API_KEY }}
        run: |
          set -euo pipefail

          sudo apt-get update -y
          sudo apt-get install -y jq

          TZ="America/New_York"
          dow=$(TZ=$TZ date +%u)         # 1..7 (Mon..Sun)
          hhmm=$(TZ=$TZ date +%H%M)      # 0000..2359
          now_iso=$(TZ=$TZ date +"%Y-%m-%d %H:%M:%S %Z")
          echo "NY_TIME=$now_iso (dow=$dow hhmm=$hhmm)"

          # Weekend guard (extra seguridad aunque el cron sea 1-5)
          if [ "$dow" -ge 6 ]; then
            echo "Outside RTH (weekend) -> exit OK"
            exit 0
          fi

          # RTH window (09:30â€“16:00)
          RTH_START=0930
          RTH_END=1600

          if [ "$hhmm" -lt "$RTH_START" ] || [ "$hhmm" -ge "$RTH_END" ]; then
            echo "Outside RTH: now=$hhmm NY -> exit OK"
            exit 0
          fi

          echo "Inside RTH: now=$hhmm NY -> running endpoints"

          get_json() {
            local path="$1"
            local url="${BASE_URL}${path}"
            curl -sS \
              -H "Authorization: Bearer ${API_KEY}" \
              -H "Content-Type: application/json" \
              --connect-timeout 5 --max-time 20 \
              "$url"
          }

          call() {
            local path="$1"
            local url="${BASE_URL}${path}"
            local tmp_body
            tmp_body="$(mktemp)"

            http_code=$(
              curl -sS -o "$tmp_body" -w "%{http_code}" \
                -H "Authorization: Bearer ${API_KEY}" \
                -H "Content-Type: application/json" \
                --connect-timeout 5 --max-time 20 \
                "$url" || echo "000"
            )

            snippet=$(head -c 300 "$tmp_body" | tr '\n' ' ' | sed 's/  */ /g')
            rm -f "$tmp_body"

            echo "ENDPOINT ${path} -> http_code=${http_code} | body_snippet=${snippet}"

            if [ "$http_code" != "200" ]; then
              echo "FAIL: ${path} returned ${http_code}"
              exit 1
            fi
          }

          # 1) Set execution mode AUTO (endpoint real)
call_method "POST" "/config/execution-mode?mode=auto"

# 2) Set risk mode LOW (endpoint real)
call_method "POST" "/config/risk-mode?mode=low"

# 3) Validate config is actually in auto
cfg="$(get_json "/config/status")"
mode="$(echo "$cfg" | jq -r '.execution_mode // empty')"
risk="$(echo "$cfg" | jq -r '.risk_mode // empty')"
echo "CHECK config/status -> execution_mode=${mode} risk_mode=${risk}"

if [ "$mode" != "auto" ]; then
  echo "FAIL: execution_mode is not auto after POST /config/execution-mode"
  echo "CFG_SNIPPET: $(echo "$cfg" | head -c 400 | tr '\n' ' ')"
  exit 1
fi

# 4) Run scan
call "/agent/scan"

# 5) Tick with skip protection
tick="$(get_json "/monitor/tick")"
tstatus="$(echo "$tick" | jq -r '.status // empty')"
treason="$(echo "$tick" | jq -r '.reason // empty')"
echo "CHECK monitor/tick -> status=${tstatus} reason=${treason}"

if [ "$tstatus" = "skipped" ]; then
  echo "FAIL: monitor/tick skipped inside RTH -> ${treason}"
  exit 1
fi

echo "All checks OK inside RTH."
